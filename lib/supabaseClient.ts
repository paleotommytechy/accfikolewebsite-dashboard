import { createClient, SupabaseClient } from '@supabase/supabase-js';

// --- IMPORTANT ---
// These credentials must be stored in environment variables.
// In development, you can use a .env file. For production, configure them
// on your hosting platform.
const supabaseUrl = 'https://tblkfcafwjconemdcrpk.supabase.co';
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRibGtmY2Fmd2pjb25lbWRjcnBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4MjMwNDksImV4cCI6MjA2ODM5OTA0OX0.RMf4-H4z9I8rdzroyl_an390s0SggD_5TqPw30vDV5Q';

// The createClient function requires strings. If the env vars are missing,
// we initialize supabase as null and the app will show a degraded state.
export const supabase: SupabaseClient | null = (supabaseUrl && supabaseAnonKey)
    ? createClient(supabaseUrl, supabaseAnonKey)
    : null;

if (!supabase) {
    console.error("Supabase URL and/or Anon Key are missing from environment variables (SUPABASE_URL, SUPABASE_ANON_KEY). The application will not be able to connect to Supabase and will be in a read-only/mocked state.");
}

/**
 * --- RECOMMENDED SUPABASE SETUP ---
 * 
 * 1. Authentication:
 *    - Enable Email provider.
 *    - Disable "Enable email confirmations" in development for easier testing.
 * 
 * 2. Database Tables & SQL Snippets:
 *    - Run the following SQL in your Supabase project's SQL Editor
 *      to create the necessary tables for the application features.
 * 
 *    ```sql
 *    -- ================================================================================================
 *    -- === CORE USER & ROLE SETUP                                                                   ===
 *    -- ================================================================================================
 *
 *    -- 1. Create public.profiles table
 *    CREATE TABLE IF NOT EXISTS public.profiles (
 *        id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
 *        full_name text,
 *        avatar_url text,
 *        fellowship_position text,
 *        level integer DEFAULT 1 NOT NULL,
 *        department text,
 *        gender text,
 *        dob text,
 *        whatsapp text,
 *        hotline text,
 *        email text,
 *        coins integer DEFAULT 0 NOT NULL,
 *        created_at timestamp with time zone DEFAULT now(),
 *        updated_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';
 *
 *    -- 2. Create user_roles table
 *    CREATE TABLE IF NOT EXISTS public.user_roles (
 *        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 *        user_id uuid NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
 *        role text NOT NULL CHECK (role IN ('member', 'admin', 'blog', 'media', 'pro', 'academics', 'finance')),
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.user_roles IS 'Stores a single role for each user (e.g., member, admin, finance).';
 *
 *    -- 3. Enable Row Level Security (RLS) for tables
 *    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
 *
 *    -- 4. Create RLS policies for profiles table
 *    DROP POLICY IF EXISTS "Authenticated users can view profiles" ON public.profiles;
 *    DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
 *    DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles;
 *    CREATE POLICY "Authenticated users can view profiles" ON public.profiles FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
 *    CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
 *
 *    -- ================================================================================================
 *    -- === GAMIFIED ONBOARDING SYSTEM (Run this to enable the Welcome Challenge)               ===
 *    -- ================================================================================================
 *
 *    -- 1. Create onboarding_progress table
 *    CREATE TABLE IF NOT EXISTS public.onboarding_progress (
 *        user_id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
 *        completed_profile boolean DEFAULT false NOT NULL,
 *        sent_first_message boolean DEFAULT false NOT NULL,
 *        rsvpd_to_event boolean DEFAULT false NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.onboarding_progress IS 'Tracks the completion of initial tasks for new users.';
 *
 *    -- 2. Enable RLS for onboarding_progress
 *    ALTER TABLE public.onboarding_progress ENABLE ROW LEVEL SECURITY;
 *
 *    -- 3. RLS Policies for onboarding_progress
 *    DROP POLICY IF EXISTS "Users can view and update their own onboarding progress" ON public.onboarding_progress;
 *    CREATE POLICY "Users can view and update their own onboarding progress" ON public.onboarding_progress
 *    FOR ALL USING (auth.uid() = user_id);
 *    
 *    -- 4. Update coin_transactions source_type to include 'onboarding'
 *    DO $$
 *    BEGIN
 *        IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'source_type_enum') THEN
 *            CREATE TYPE public.source_type_enum AS ENUM ('task', 'challenge', 'admin_adjustment', 'quiz', 'onboarding');
 *        ELSE
 *            ALTER TYPE public.source_type_enum ADD VALUE IF NOT EXISTS 'onboarding';
 *        END IF;
 *    END
 *    $$;
 *
 *    -- ================================================================================================
 *    -- === SPONSORSHIP SYSTEM                                                                         ===
 *    -- ================================================================================================
 *
 *    -- 1. Create sponsorship_inquiries table
 *    CREATE TABLE IF NOT EXISTS public.sponsorship_inquiries (
 *        id uuid NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
 *        created_at timestamp with time zone DEFAULT now(),
 *        name text NOT NULL,
 *        organization text,
 *        email text NOT NULL,
 *        phone text,
 *        interest text,
 *        message text,
 *        status text NOT NULL DEFAULT 'new' CHECK (status IN ('new', 'contacted', 'closed'))
 *    );
 *    COMMENT ON TABLE public.sponsorship_inquiries IS 'Stores inquiries from potential sponsors.';
 *
 *    -- 2. Enable RLS
 *    ALTER TABLE public.sponsorship_inquiries ENABLE ROW LEVEL SECURITY;
 *
 *    -- 3. RLS Policies
 *    -- Allow authenticated users to submit inquiries.
 *    DROP POLICY IF EXISTS "Authenticated users can submit inquiries" ON public.sponsorship_inquiries;
 *    CREATE POLICY "Authenticated users can submit inquiries" ON public.sponsorship_inquiries FOR INSERT TO authenticated WITH CHECK (true);
 *
 *    -- Allow admins to view and manage all inquiries.
 *    DROP POLICY IF EXISTS "Admins can manage inquiries" ON public.sponsorship_inquiries;
 *    CREATE POLICY "Admins can manage inquiries" ON public.sponsorship_inquiries FOR ALL USING (
 *        (SELECT role FROM public.user_roles WHERE user_id = auth.uid()) = 'admin'
 *    );
 *
 *    -- ================================================================================================
 *    -- === DEPRECATED: NEW USER ONBOARDING TRIGGER                                                    ===
 *    -- ================================================================================================
 *    --
 *    -- NOTE: The database trigger for new user onboarding has been removed.
 *    -- It was causing persistent "Database error saving new user" errors for some OAuth sign-ups.
 *    -- The logic has been moved to the client-side in `/context/AppContext.tsx`.
 *    -- The new approach is for the client to detect a missing profile for an authenticated user
 *    -- and create it on the fly. This is more resilient to RLS policies and auth provider variations.
 *    --
 *    -- Run these DROP commands in your SQL Editor to remove the old function and trigger.
 *    
 *    DROP TRIGGER IF EXISTS on_auth_user_created_onboarding ON auth.users;
 *    DROP FUNCTION IF EXISTS public.handle_new_user_onboarding();
 *    --
 *    -- ================================================================================================
 *
 *    -- ================================================================================================
 *    -- === TASK & NOTIFICATION MANAGEMENT                                                           ===
 *    -- ================================================================================================
 *
 *    -- This function assigns a task to all users for the current day.
 *    -- It checks to prevent duplicate assignments if run multiple times a day.
 *    -- Crucially, it creates notifications for 'task_assigned' ONLY for users who are NOT admins.
 *    CREATE OR REPLACE FUNCTION assign_task_to_all_users(task_id_to_assign uuid)
 *    RETURNS void AS $$
 *    DECLARE
 *        user_record RECORD;
 *        task_record RECORD;
 *        assignment_exists boolean;
 *    BEGIN
 *        -- Get task details for the notification message
 *        SELECT * INTO task_record FROM public.tasks WHERE id = task_id_to_assign;
 *    
 *        IF NOT FOUND THEN
 *            RAISE EXCEPTION 'Task with id % not found', task_id_to_assign;
 *        END IF;
 *    
 *        -- Loop through all users and their roles
 *        FOR user_record IN 
 *            SELECT u.id, ur.role 
 *            FROM auth.users u
 *            LEFT JOIN public.user_roles ur ON u.id = ur.user_id
 *        LOOP
 *            -- Check if a task assignment for this task and user already exists for today
 *            SELECT EXISTS (
 *                SELECT 1 FROM public.tasks_assignments
 *                WHERE assignee_id = user_record.id
 *                AND task_id = task_id_to_assign
 *                AND created_at >= date_trunc('day', now())
 *                AND created_at < date_trunc('day', now()) + interval '1 day'
 *            ) INTO assignment_exists;
 *    
 *            -- If no assignment exists for today, create one
 *            IF NOT assignment_exists THEN
 *                INSERT INTO public.tasks_assignments (task_id, assignee_id, status)
 *                VALUES (task_id_to_assign, user_record.id, 'assigned');
 *    
 *                -- Create a notification for the user, ONLY if they are NOT an admin
 *                IF user_record.role IS NULL OR user_record.role != 'admin' THEN
 *                    INSERT INTO public.notifications (user_id, type, message, link)
 *                    VALUES (
 *                        user_record.id,
 *                        'task_assigned',
 *                        'Your daily task "' || task_record.title || '" has been assigned.',
 *                        '/tasks'
 *                    );
 *                END IF;
 *            END IF;
 *        END LOOP;
 *    END;
 *    $$ LANGUAGE plpgsql SECURITY DEFINER;
 * 
 *    ```
 * 
 */