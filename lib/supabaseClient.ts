import { createClient, SupabaseClient } from '@supabase/supabase-js';

// --- IMPORTANT ---
// These credentials must be stored in environment variables.
// In development, you can use a .env file. For production, configure them
// on your hosting platform.
const supabaseUrl = 'https://tblkfcafwjconemdcrpk.supabase.co';
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRibGtmY2Fmd2pjb25lbWRjcnBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4MjMwNDksImV4cCI6MjA2ODM5OTA0OX0.RMf4-H4z9I8rdzroyl_an390s0SggD_5TqPw30vDV5Q';

// The createClient function requires strings. If the env vars are missing,
// we initialize supabase as null and the app will show a degraded state.
export const supabase: SupabaseClient | null = (supabaseUrl && supabaseAnonKey)
    ? createClient(supabaseUrl, supabaseAnonKey)
    : null;

if (!supabase) {
    console.error("Supabase URL and/or Anon Key are missing from environment variables (SUPABASE_URL, SUPABASE_ANON_KEY). The application will not be able to connect to Supabase and will be in a read-only/mocked state.");
}

/**
 * --- RECOMMENDED SUPABASE SETUP ---
 * 
 * 1. Authentication:
 *    - Enable Email provider.
 *    - Disable "Enable email confirmations" in development for easier testing.
 * 
 * 2. Database Tables & SQL Snippets:
 *    - Run the following SQL in your Supabase project's SQL Editor
 *      to create the necessary tables for the application features.
 * 
 *    ```sql
 *    -- ================================================================================================
 *    -- === FIX: USER PROFILE & ROLE SETUP (Run this section to fix sign-up & RLS errors)            ===
 *    -- ================================================================================================
 *
 *    -- 1. Create public.profiles table
 *    CREATE TABLE IF NOT EXISTS public.profiles (
 *        id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
 *        full_name text,
 *        avatar_url text,
 *        fellowship_position text,
 *        level integer DEFAULT 1 NOT NULL,
 *        department text,
 *        gender text,
 *        dob text,
 *        whatsapp text,
 *        hotline text,
 *        email text UNIQUE,
 *        coins integer DEFAULT 0 NOT NULL,
 *        created_at timestamp with time zone DEFAULT now(),
 *        updated_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';
 *
 *    -- 2. Create user_roles table
 *    -- UPDATED: Added 'finance' to the list of accepted roles
 *    CREATE TABLE IF NOT EXISTS public.user_roles (
 *        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 *        user_id uuid NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
 *        role text NOT NULL CHECK (role IN ('member', 'admin', 'blog', 'media', 'pro', 'academics', 'finance')),
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.user_roles IS 'Stores a single role for each user (e.g., member, admin, finance).';
 *
 *    -- 3. Enable Row Level Security (RLS) for tables
 *    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
 *
 *    -- 4. Create RLS policies for profiles table
 *    DROP POLICY IF EXISTS "Authenticated users can view profiles" ON public.profiles;
 *    DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
 *    DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles; -- ADDED: Drop policy if exists
 *    CREATE POLICY "Authenticated users can view profiles" ON public.profiles FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
 *    CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id); -- SOLUTION: Added missing INSERT policy
 *
 *    -- Helper function to securely get the current user's role.
 *    -- It's defined with `SECURITY DEFINER` to run with the permissions of the owner,
 *    -- which allows it to bypass RLS on the `user_roles` table and prevent recursion.
 *    -- The table is schema-qualified (`public.user_roles`) for robustness.
 *    CREATE OR REPLACE FUNCTION public.get_my_role()
 *    RETURNS TEXT
 *    LANGUAGE sql
 *    STABLE
 *    SECURITY DEFINER
 *    AS $$
 *      SELECT role FROM public.user_roles WHERE user_id = auth.uid();
 *    $$;
 *
 *    -- 5. Create RLS policies for user_roles table
 *    DROP POLICY IF EXISTS "Users can manage and view appropriate roles" ON public.user_roles; -- Drop old policy
 *    DROP POLICY IF EXISTS "Users can view their own role, admins can view all" ON public.user_roles;
 *    DROP POLICY IF EXISTS "Admins can insert new roles" ON public.user_roles;
 *    DROP POLICY IF EXISTS "Users can create their own role, admins can insert any" ON public.user_roles;
 *    DROP POLICY IF EXISTS "New users can create their own member role" ON public.user_roles; -- ADDED: Drop policy if exists
 *    DROP POLICY IF EXISTS "Admins can update roles" ON public.user_roles;
 *    DROP POLICY IF EXISTS "Admins can delete roles" ON public.user_roles;
 *
 *    -- Policy for SELECT: Users can see their own role, admins can see all roles.
 *    CREATE POLICY "Users can view their own role, admins can view all" ON public.user_roles
 *    FOR SELECT
 *    USING ( (auth.uid() = user_id) OR (public.get_my_role() = 'admin') );
 *    
 *    -- SOLUTION: Replaced the recursive INSERT policy with a secure, non-recursive one.
 *    -- A new user can insert their own initial 'member' role. This prevents a user
 *    -- from making themselves an admin. Admins should use the 'update_user_role'
 *    -- function to elevate privileges, so an admin INSERT policy is not needed.
 *    CREATE POLICY "New users can create their own member role" ON public.user_roles
 *    FOR INSERT
 *    WITH CHECK ( (auth.uid() = user_id) AND (role = 'member') );
 *
 *    -- ================================================================================================
 *    -- === NEW: GAMIFIED ONBOARDING SYSTEM                                                          ===
 *    -- ================================================================================================
 *
 *    -- 1. Create onboarding_progress table
 *    CREATE TABLE IF NOT EXISTS public.onboarding_progress (
 *        user_id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
 *        completed_profile boolean DEFAULT false NOT NULL,
 *        sent_first_message boolean DEFAULT false NOT NULL,
 *        rsvpd_to_event boolean DEFAULT false NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.onboarding_progress IS 'Tracks the completion of initial tasks for new users.';
 *
 *    -- 2. Enable RLS for onboarding_progress
 *    ALTER TABLE public.onboarding_progress ENABLE ROW LEVEL SECURITY;
 *
 *    -- 3. RLS Policies for onboarding_progress
 *    DROP POLICY IF EXISTS "Users can view and update their own onboarding progress" ON public.onboarding_progress;
 *    CREATE POLICY "Users can view and update their own onboarding progress" ON public.onboarding_progress
 *    FOR ALL USING (auth.uid() = user_id);
 *    
 *    -- 4. Function to create onboarding progress record on new user sign-up
 *    CREATE OR REPLACE FUNCTION public.handle_new_user_onboarding()
 *    RETURNS TRIGGER
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER -- IMPORTANT: Required to insert into tables owned by postgres
 *    AS $$
 *    BEGIN
 *      -- Create a profile and role for the new user
 *      INSERT INTO public.profiles (id, full_name, email)
 *      VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name', NEW.email);
 *
 *      INSERT INTO public.user_roles (user_id, role)
 *      VALUES (NEW.id, 'member');
 *
 *      -- Create the onboarding progress tracker
 *      INSERT INTO public.onboarding_progress (user_id)
 *      VALUES (NEW.id);
 *
 *      RETURN NEW;
 *    END;
 *    $$;
 *
 *    -- 5. Trigger to execute the function after a new user is created in auth.users
 *    DROP TRIGGER IF EXISTS on_auth_user_created_onboarding ON auth.users;
 *    CREATE TRIGGER on_auth_user_created_onboarding
 *      AFTER INSERT ON auth.users
 *      FOR EACH ROW EXECUTE FUNCTION public.handle_new_user_onboarding();
 *      
 *    -- 6. Helper functions to check user's first actions
 *    CREATE OR REPLACE FUNCTION public.has_sent_message(p_user_id uuid)
 *    RETURNS boolean
 *    LANGUAGE sql
 *    STABLE
 *    AS $$
 *      SELECT EXISTS (SELECT 1 FROM public.messages WHERE sender_id = p_user_id);
 *    $$;
 *
 *    CREATE OR REPLACE FUNCTION public.has_rsvpd(p_user_id uuid)
 *    RETURNS boolean
 *    LANGUAGE sql
 *    STABLE
 *    AS $$
 *      SELECT EXISTS (SELECT 1 FROM public.event_rsvps WHERE user_id = p_user_id);
 *    $$;
 *    
 *    -- 7. Update coin_transactions source_type to include 'onboarding'
 *    -- This is an ALTER TYPE statement. If it fails, you may need to drop and recreate the type
 *    -- and any views/functions that depend on it. BACKUP FIRST.
 *    -- Example: ALTER TYPE public.source_type_enum ADD VALUE 'onboarding';
 *
 *    -- ================================================================================================
 *    -- === END OF GAMIFIED ONBOARDING SYSTEM                                                        ===
 *    -- ================================================================================================
 * 
 *    ```
 * 
 */
