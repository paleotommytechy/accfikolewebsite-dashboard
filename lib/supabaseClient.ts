import { createClient, SupabaseClient } from '@supabase/supabase-js';

// --- IMPORTANT ---
// These credentials must be stored in environment variables.
// In development, you can use a .env file. For production, configure them
// on your hosting platform.
const supabaseUrl = 'https://tblkfcafwjconemdcrpk.supabase.co';
const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRibGtmY2Fmd2pjb25lbWRjcnBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTI4MjMwNDksImV4cCI6MjA2ODM5OTA0OX0.RMf4-H4z9I8rdzroyl_an390s0SggD_5TqPw30vDV5Q';

// The createClient function requires strings. If the env vars are missing,
// we initialize supabase as null and the app will show a degraded state.
export const supabase: SupabaseClient | null = (supabaseUrl && supabaseAnonKey)
    ? createClient(supabaseUrl, supabaseAnonKey)
    : null;

if (!supabase) {
    console.error("Supabase URL and/or Anon Key are missing from environment variables (SUPABASE_URL, SUPABASE_ANON_KEY). The application will not be able to connect to Supabase and will be in a read-only/mocked state.");
}

/**
 * --- RECOMMENDED SUPABASE SETUP ---
 * 
 * 1. Authentication:
 *    - Enable Email provider.
 *    - Disable "Enable email confirmations" in development for easier testing.
 * 
 * 2. Database Tables & SQL Snippets:
 *    - Run the following SQL in your Supabase project's SQL Editor
 *      to create the necessary tables for the application features.
 * 
 *    ```sql
 *    -- ================================================================================================
 *    -- === FIX: USER PROFILE & ROLE SETUP (Run this section to fix sign-up & RLS errors)            ===
 *    -- ================================================================================================
 *
 *    -- 1. Create public.profiles table
 *    CREATE TABLE IF NOT EXISTS public.profiles (
 *        id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
 *        full_name text,
 *        avatar_url text,
 *        fellowship_position text,
 *        level integer DEFAULT 1 NOT NULL,
 *        department text,
 *        gender text,
 *        dob text,
 *        whatsapp text,
 *        hotline text,
 *        email text UNIQUE,
 *        coins integer DEFAULT 0 NOT NULL,
 *        created_at timestamp with time zone DEFAULT now(),
 *        updated_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.profiles IS 'Stores public profile information for each user.';
 *
 *    -- 2. Create user_roles table
 *    -- UPDATED: Added 'finance' to the list of accepted roles
 *    CREATE TABLE IF NOT EXISTS public.user_roles (
 *        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 *        user_id uuid NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
 *        role text NOT NULL CHECK (role IN ('member', 'admin', 'blog', 'media', 'pro', 'academics', 'finance')),
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.user_roles IS 'Stores a single role for each user (e.g., member, admin, finance).';
 *
 *    -- 3. Enable Row Level Security (RLS) for tables
 *    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
 *
 *    -- 4. Create RLS policies for profiles table
 *    DROP POLICY IF EXISTS "Authenticated users can view profiles" ON public.profiles;
 *    DROP POLICY IF EXISTS "Users can update their own profile" ON public.profiles;
 *    DROP POLICY IF EXISTS "Users can insert their own profile" ON public.profiles; -- ADDED: Drop policy if exists
 *    CREATE POLICY "Authenticated users can view profiles" ON public.profiles FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
 *    CREATE POLICY "Users can insert their own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id); -- SOLUTION: Added missing INSERT policy
 *
 *    -- Helper function to securely get the current user's role.
 *    -- It's defined with `SECURITY DEFINER` to run with the permissions of the owner,
 *    -- which allows it to bypass RLS on the `user_roles` table and prevent recursion.
 *    -- The table is schema-qualified (`public.user_roles`) for robustness.
 *    CREATE OR REPLACE FUNCTION public.get_my_role()
 *    RETURNS TEXT
 *    LANGUAGE sql
 *    STABLE
 *    SECURITY DEFINER
 *    AS $$
 *      SELECT role FROM public.user_roles WHERE user_id = auth.uid();
 *    $$;
 *
 *    -- 5. Create RLS policies for user_roles table
 *    DROP POLICY IF EXISTS "Users can manage and view appropriate roles" ON public.user_roles; -- Drop old policy
 *    DROP POLICY IF EXISTS "Users can view their own role, admins can view all" ON public.user_roles;
 *    DROP POLICY IF EXISTS "Admins can insert new roles" ON public.user_roles;
 *    DROP POLICY IF EXISTS "Users can create their own role, admins can insert any" ON public.user_roles;
 *    DROP POLICY IF EXISTS "New users can create their own member role" ON public.user_roles; -- ADDED: Drop policy if exists
 *    DROP POLICY IF EXISTS "Admins can update roles" ON public.user_roles;
 *    DROP POLICY IF EXISTS "Admins can delete roles" ON public.user_roles;
 *
 *    -- Policy for SELECT: Users can see their own role, admins can see all roles.
 *    CREATE POLICY "Users can view their own role, admins can view all" ON public.user_roles
 *    FOR SELECT
 *    USING ( (auth.uid() = user_id) OR (public.get_my_role() = 'admin') );
 *    
 *    -- SOLUTION: Replaced the recursive INSERT policy with a secure, non-recursive one.
 *    -- A new user can insert their own initial 'member' role. This prevents a user
 *    -- from making themselves an admin. Admins should use the 'update_user_role'
 *    -- function to elevate privileges, so an admin INSERT policy is not needed.
 *    CREATE POLICY "New users can create their own member role" ON public.user_roles
 *    FOR INSERT
 *    WITH CHECK ( auth.uid() = user_id AND role = 'member' );
 *
 *    -- Policy for UPDATE: Only admins can update roles.
 *    CREATE POLICY "Admins can update roles" ON public.user_roles
 *    FOR UPDATE
 *    USING ( public.get_my_role() = 'admin' )
 *    WITH CHECK ( public.get_my_role() = 'admin' );
 *    
 *    -- Policy for DELETE: Only admins can delete roles.
 *    CREATE POLICY "Admins can delete roles" ON public.user_roles
 *    FOR DELETE
 *    USING ( public.get_my_role() = 'admin' );
 *
 *    -- 6. Create function to handle new user creation
 *    -- This function is triggered when a new user signs up.
 *    CREATE OR REPLACE FUNCTION public.handle_new_user()
 *    RETURNS trigger
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER
 *    AS $$
 *    BEGIN
 *      -- Insert a new row into public.profiles
 *      INSERT INTO public.profiles (id, email, full_name)
 *      VALUES (
 *        new.id,
 *        new.email,
 *        new.raw_user_meta_data->>'full_name'
 *      );
 *
 *      -- Insert a default role for the new user into public.user_roles
 *      INSERT INTO public.user_roles (user_id, role)
 *      VALUES (new.id, 'member');
 *
 *      RETURN new;
 *    END;
 *    $$;
 *
 *    -- 7. Create a trigger to call the function on new user sign-up
 *    DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
 *    CREATE TRIGGER on_auth_user_created
 *      AFTER INSERT ON auth.users
 *      FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
 *
 *    -- 8. Create admin RPC functions used by the app
 *    -- FIX: Updated RPC functions to use the get_my_role() helper to prevent potential recursion.
 *    CREATE OR REPLACE FUNCTION public.update_user_role(target_user_id uuid, new_role text)
 *    RETURNS void
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER AS $$
 *    BEGIN
 *      IF public.get_my_role() != 'admin' THEN
 *        RAISE EXCEPTION 'Only admins can change user roles.';
 *      END IF;
 *      UPDATE public.user_roles SET role = new_role WHERE user_id = target_user_id;
 *    END;
 *    $$;
 *
 *    CREATE OR REPLACE FUNCTION public.delete_user_account(target_user_id uuid)
 *    RETURNS void
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER AS $$
 *    BEGIN
 *      IF public.get_my_role() != 'admin' THEN
 *        RAISE EXCEPTION 'Only admins can delete users.';
 *      END IF;
 *      DELETE FROM auth.users WHERE id = target_user_id;
 *    END;
 *    $$;
 *
 *    -- ================================================================================================
 *    -- === STREAKS & BONUSES (NEW)                                                                  ===
 *    -- ================================================================================================
 *    -- 1. Add streak columns to the profiles table
 *    ALTER TABLE public.profiles
 *    ADD COLUMN IF NOT EXISTS current_streak integer DEFAULT 0 NOT NULL,
 *    ADD COLUMN IF NOT EXISTS longest_streak integer DEFAULT 0 NOT NULL,
 *    ADD COLUMN IF NOT EXISTS last_streak_day date;
 *
 *    COMMENT ON COLUMN public.profiles.current_streak IS 'User''s current daily task completion streak.';
 *    COMMENT ON COLUMN public.profiles.longest_streak IS 'User''s longest-ever daily task completion streak.';
 *    COMMENT ON COLUMN public.profiles.last_streak_day IS 'The last date the streak was updated or maintained.';
 *    
 *    -- 2. Create a function to update user streaks upon completion of all daily tasks
 *    CREATE OR REPLACE FUNCTION public.update_user_streak(p_user_id uuid)
 *    RETURNS void
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER AS $$
 *    DECLARE
 *      today_date date := current_date;
 *      yesterday_date date := current_date - interval '1 day';
 *      last_day date;
 *      total_daily_tasks integer;
 *      completed_daily_tasks integer;
 *      current_s integer;
 *    BEGIN
 *      -- Check if all daily tasks for today are completed for the user
 *      SELECT count(*) INTO total_daily_tasks
 *      FROM public.tasks_assignments ta
 *      JOIN public.tasks t ON ta.task_id = t.id
 *      WHERE ta.assignee_id = p_user_id
 *        AND t.frequency = 'daily'
 *        AND date(ta.created_at) = today_date;
 *    
 *      IF total_daily_tasks = 0 THEN
 *        -- No daily tasks assigned for today, so streak is not affected.
 *        RETURN;
 *      END IF;
 *    
 *      SELECT count(*) INTO completed_daily_tasks
 *      FROM public.tasks_assignments ta
 *      JOIN public.tasks t ON ta.task_id = t.id
 *      WHERE ta.assignee_id = p_user_id
 *        AND t.frequency = 'daily'
 *        AND date(ta.created_at) = today_date
 *        AND ta.status = 'done';
 *    
 *      -- Only proceed if all daily tasks for today are done
 *      IF total_daily_tasks > 0 AND completed_daily_tasks = total_daily_tasks THEN
 *        -- Get the user's current streak info
 *        SELECT current_streak, last_streak_day INTO current_s, last_day
 *        FROM public.profiles
 *        WHERE id = p_user_id;
 *        
 *        -- Avoid double-incrementing on the same day
 *        IF last_day = today_date THEN
 *          RETURN;
 *        END IF;
 *    
 *        -- Update streak logic
 *        IF last_day = yesterday_date THEN
 *          -- Streak continues, increment it
 *          current_s := COALESCE(current_s, 0) + 1;
 *        ELSE
 *          -- Streak is broken or new, reset to 1
 *          current_s := 1;
 *        END IF;
 *    
 *        -- Update the profile
 *        UPDATE public.profiles
 *        SET
 *          current_streak = current_s,
 *          longest_streak = GREATEST(longest_streak, current_s),
 *          last_streak_day = today_date
 *        WHERE id = p_user_id;
 *        
 *      END IF;
 *    END;
 *    $$;
 *
 *    -- ================================================================================================
 *    -- === GIVING & DONATION SYSTEM (NEW)                                                          ===
 *    -- ================================================================================================
 *    
 *    -- 1. Create donations table
 *    CREATE TABLE IF NOT EXISTS public.donations (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        amount integer NOT NULL,
 *        fund_name text NOT NULL,
 *        status text DEFAULT 'pending'::text NOT NULL CHECK (status IN ('pending', 'confirmed', 'rejected')),
 *        created_at timestamp with time zone DEFAULT now(),
 *        confirmed_at timestamp with time zone
 *    );
 *    COMMENT ON TABLE public.donations IS 'Stores user donation intentions and their confirmation status.';
 *
 *    -- 2. Enable RLS and create policies for donations
 *    ALTER TABLE public.donations ENABLE ROW LEVEL SECURITY;
 *    DROP POLICY IF EXISTS "Users can view their own donations" ON public.donations;
 *    CREATE POLICY "Users can view their own donations" ON public.donations FOR SELECT USING (auth.uid() = user_id);
 *
 *    DROP POLICY IF EXISTS "Users can insert their own donation records" ON public.donations;
 *    CREATE POLICY "Users can insert their own donation records" ON public.donations FOR INSERT WITH CHECK (auth.uid() = user_id);
 *
 *    -- UPDATED: Allow 'finance' role to also manage donations
 *    DROP POLICY IF EXISTS "Admins and Finance can manage all donations" ON public.donations;
 *    CREATE POLICY "Admins and Finance can manage all donations" ON public.donations 
 *    FOR ALL USING (public.get_my_role() IN ('admin', 'finance'));
 *
 *    -- 3. RPC to update donation status and send notification/message
 *    -- UPDATED: Allow 'finance' role to call this function
 *    CREATE OR REPLACE FUNCTION public.update_donation_status(
 *        p_donation_id uuid,
 *        p_new_status text,
 *        p_admin_id uuid
 *    )
 *    RETURNS void
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER AS $$
 *    DECLARE
 *      donation_record RECORD;
 *      notification_message TEXT;
 *    BEGIN
 *      IF public.get_my_role() NOT IN ('admin', 'finance') THEN
 *        RAISE EXCEPTION 'Only admins or finance managers can update donation status.';
 *      END IF;
 *
 *      -- Get donation details for the message
 *      SELECT * INTO donation_record FROM public.donations WHERE id = p_donation_id;
 *      
 *      IF NOT FOUND THEN
 *        RAISE EXCEPTION 'Donation not found.';
 *      END IF;
 *
 *      -- Update the donation status
 *      UPDATE public.donations
 *      SET 
 *        status = p_new_status,
 *        confirmed_at = CASE WHEN p_new_status = 'confirmed' THEN now() ELSE confirmed_at END
 *      WHERE id = p_donation_id;
 *      
 *      -- Create a notification and in-app message for the user
 *      IF p_new_status = 'confirmed' THEN
 *        notification_message := 'Your donation of ₦' || donation_record.amount::text || ' for "' || donation_record.fund_name || '" has been confirmed. Thank you so much for your generosity! God bless you.';
 *      ELSIF p_new_status = 'rejected' THEN
 *         notification_message := 'There was an issue confirming your donation of ₦' || donation_record.amount::text || '. An admin will contact you shortly to clarify.';
 *      ELSE
 *        -- For 'pending' or other statuses, do not send anything.
 *        RETURN;
 *      END IF;
 *      
 *      INSERT INTO public.notifications(user_id, type, message, link, metadata)
 *      VALUES (donation_record.user_id, 'custom', notification_message, '/giving', jsonb_build_object('donationId', p_donation_id));
 *      
 *      INSERT INTO public.messages(sender_id, recipient_id, text)
 *      VALUES (p_admin_id, donation_record.user_id, notification_message);
 *
 *    END;
 *    $$;
 *
 *    -- ================================================================================================
 *    -- === GAMIFICATION & CORE FEATURES SETUP                                                       ===
 *    -- ================================================================================================
 *
 *    -- 1. Create tasks table
 *    CREATE TABLE IF NOT EXISTS public.tasks (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        title text NOT NULL,
 *        frequency text CHECK (frequency IN ('daily', 'once', 'weekly')),
 *        details text,
 *        due_date date,
 *        created_at timestamp with time zone DEFAULT now(),
 *        updated_at timestamp with time zone,
 *        coin_reward integer NOT NULL,
 *        time_gate_minutes integer
 *    );
 *    ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Authenticated users can view tasks" ON public.tasks FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Admins can manage tasks" ON public.tasks FOR ALL USING (public.get_my_role() = 'admin');
 *
 *    -- 2. Create tasks_assignments table
 *    CREATE TABLE IF NOT EXISTS public.tasks_assignments (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        task_id uuid NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
 *        assignee_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        status text DEFAULT 'assigned'::text NOT NULL CHECK (status IN ('assigned', 'done')),
 *        completed_at timestamp with time zone,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    ALTER TABLE public.tasks_assignments ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Users can manage their own assignments" ON public.tasks_assignments FOR ALL USING (auth.uid() = assignee_id);
 *
 *    -- 3. Create weekly_challenges table
 *    CREATE TABLE IF NOT EXISTS public.weekly_challenges (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        title text NOT NULL,
 *        details text,
 *        start_date date,
 *        due_date date,
 *        rules text,
 *        created_at timestamp with time zone DEFAULT now(),
 *        coin_reward integer NOT NULL,
 *        has_quiz boolean DEFAULT false NOT NULL
 *    );
 *    ALTER TABLE public.weekly_challenges ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Authenticated users can view challenges" ON public.weekly_challenges FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Admins can manage challenges" ON public.weekly_challenges FOR ALL USING (public.get_my_role() = 'admin');
 *
 *    -- 4. Create weekly_participants table (WITH FOREIGN KEY FIX)
 *    CREATE TABLE IF NOT EXISTS public.weekly_participants (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        challenge_id uuid NOT NULL REFERENCES public.weekly_challenges(id) ON DELETE CASCADE,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE, -- This FK resolves the error
 *        progress integer DEFAULT 0 NOT NULL,
 *        streak integer DEFAULT 0 NOT NULL,
 *        joined_at timestamp with time zone DEFAULT now(),
 *        UNIQUE(challenge_id, user_id)
 *    );
 *    ALTER TABLE public.weekly_participants ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Users can manage their own participation" ON public.weekly_participants FOR ALL USING (auth.uid() = user_id);
 *    CREATE POLICY "Authenticated users can view all participation" ON public.weekly_participants FOR SELECT TO authenticated USING (true);
 *
 *    -- 5. Create coin_transactions table
 *    CREATE TABLE IF NOT EXISTS public.coin_transactions (
 *        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        source_type text NOT NULL CHECK (source_type IN ('task', 'challenge', 'admin_adjustment', 'quiz')),
 *        source_id text NOT NULL,
 *        coin_amount integer NOT NULL,
 *        status text NOT NULL CHECK (status IN ('pending', 'approved', 'rejected')),
 *        created_at timestamp with time zone DEFAULT now(),
 *        reason text
 *    );
 *    ALTER TABLE public.coin_transactions ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Users can view their own transactions" ON public.coin_transactions FOR SELECT USING (auth.uid() = user_id);
 *    CREATE POLICY "Admins can manage transactions" ON public.coin_transactions FOR ALL USING (public.get_my_role() = 'admin');
 *    
 *    -- ================================================================================================
 *    -- === EVENT SYSTEM SETUP (UPDATED)                                                             ===
 *    -- ================================================================================================
 *    -- 1. Create Storage Bucket for Event Images:
 *    -- Go to your Supabase project -> Storage -> Create bucket
 *    -- Bucket name: event_images
 *    -- Check "Public bucket"
 *
 *    -- 2. SQL Policies for 'event_images' bucket (run these in the SQL Editor)
 *    -- [FIX] This policy is now more robust. It allows authorized users to upload to a path starting with `public/{their_user_id}/`.
 *    DROP POLICY IF EXISTS "Event image insert policy" ON storage.objects;
 *    CREATE POLICY "Event image insert policy" ON storage.objects FOR INSERT TO authenticated WITH CHECK (
 *        bucket_id = 'event_images'
 *        AND (select get_my_role()) IN ('admin', 'pro')
 *        AND name LIKE 'public/' || auth.uid()::text || '/%'
 *    );
 *
 *    -- This policy allows admins and pro members to update any image in the bucket.
 *    DROP POLICY IF EXISTS "Event image update policy" ON storage.objects;
 *    CREATE POLICY "Event image update policy" ON storage.objects FOR UPDATE TO authenticated USING (
 *        bucket_id = 'event_images' AND (select get_my_role()) IN ('admin', 'pro')
 *    );
 *
 *    -- This policy allows admins and pro members to delete any image in the bucket.
 *    DROP POLICY IF EXISTS "Event image delete policy" ON storage.objects;
 *    CREATE POLICY "Event image delete policy" ON storage.objects FOR DELETE TO authenticated USING (
 *        bucket_id = 'event_images' AND (select get_my_role()) IN ('admin', 'pro')
 *    );
 *
 *    -- 3. Create events table
 *    CREATE TABLE IF NOT EXISTS public.events (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        title text NOT NULL,
 *        date date NOT NULL,
 *        "time" time without time zone NOT NULL,
 *        location text NOT NULL,
 *        description text NOT NULL,
 *        image_url text,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.events IS 'Stores fellowship events information.';
 *
 *    -- 4. Enable RLS
 *    ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;
 *
 *    -- 5. RLS Policies for events
 *    DROP POLICY IF EXISTS "Authenticated users can view events" ON public.events;
 *    CREATE POLICY "Authenticated users can view events" ON public.events
 *    FOR SELECT TO authenticated USING (true);
 *
 *    DROP POLICY IF EXISTS "Admins can manage events" ON public.events;
 *    -- UPDATED: Allow 'pro' role to also manage events
 *    CREATE POLICY "Admins and pros can manage events" ON public.events
 *    FOR ALL USING (public.get_my_role() IN ('admin', 'pro'))
 *    WITH CHECK (public.get_my_role() IN ('admin', 'pro'));
 *    
 *    -- ================================================================================================
 *    -- === EVENT RSVP SYSTEM (NEW)                                                                  ===
 *    -- ================================================================================================
 *
 *    -- 1. Create event_rsvps table
 *    CREATE TABLE IF NOT EXISTS public.event_rsvps (
 *        event_id uuid NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        created_at timestamp with time zone DEFAULT now(),
 *        PRIMARY KEY (event_id, user_id)
 *    );
 *    COMMENT ON TABLE public.event_rsvps IS 'Tracks user RSVPs for events.';
 *
 *    -- 2. Enable RLS
 *    ALTER TABLE public.event_rsvps ENABLE ROW LEVEL SECURITY;
 *
 *    -- 3. RLS Policies
 *    -- Allow authenticated users to view all RSVPs (useful for seeing who is coming)
 *    DROP POLICY IF EXISTS "Authenticated users can view RSVPs" ON public.event_rsvps;
 *    CREATE POLICY "Authenticated users can view RSVPs" ON public.event_rsvps
 *    FOR SELECT TO authenticated USING (true);
 *
 *    -- Allow users to manage their own RSVPs (insert and delete)
 *    DROP POLICY IF EXISTS "Users can manage their own RSVPs" ON public.event_rsvps;
 *    CREATE POLICY "Users can manage their own RSVPs" ON public.event_rsvps
 *    FOR ALL USING (auth.uid() = user_id);
 *
 *    -- ================================================================================================
 *    -- === BLOG SYSTEM SETUP (NEW)                                                                ===
 *    -- ================================================================================================
 *    
 *    -- 1. Create Storage Bucket for Blog Images:
 *    -- Go to your Supabase project -> Storage -> Create bucket
 *    -- Bucket name: blog_images
 *    -- Check "Public bucket"
 *    
 *    -- 2. SQL Policies for 'blog_images' bucket (run these in the SQL Editor)
 *    -- [FIX] This policy is now more robust. It allows authorized users to upload to a path starting with `public/blog_images/{their_user_id}/`.
 *    DROP POLICY IF EXISTS "Blog image insert policy" ON storage.objects;
 *    CREATE POLICY "Blog image insert policy" ON storage.objects FOR INSERT TO authenticated WITH CHECK (
 *        bucket_id = 'blog_images'
 *        AND (select get_my_role()) IN ('admin', 'blog')
 *        AND name LIKE 'public/blog_images/' || auth.uid()::text || '/%'
 *    );
 *
 *    DROP POLICY IF EXISTS "Blog image update policy" ON storage.objects;
 *    CREATE POLICY "Blog image update policy" ON storage.objects FOR UPDATE TO authenticated USING (
 *        bucket_id = 'blog_images' AND (select get_my_role()) IN ('admin', 'blog')
 *    );
 *    
 *    DROP POLICY IF EXISTS "Blog image delete policy" ON storage.objects;
 *    CREATE POLICY "Blog image delete policy" ON storage.objects FOR DELETE TO authenticated USING (
 *        bucket_id = 'blog_images' AND (select get_my_role()) IN ('admin', 'blog')
 *    );
 *
 *    -- 3. Create posts table
 *    CREATE TABLE IF NOT EXISTS public.posts (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        author_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        title text NOT NULL,
 *        content text NOT NULL,
 *        category text CHECK (category IN ('Devotional', 'Bible Study', 'Announcement', 'Other')),
 *        image_url text,
 *        likes_count integer DEFAULT 0 NOT NULL,
 *        comments_count integer DEFAULT 0 NOT NULL,
 *        status text DEFAULT 'published'::text NOT NULL,
 *        created_at timestamp with time zone DEFAULT now(),
 *        updated_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.posts IS 'Stores blog posts.';
 *
 *    -- 4. Create post_likes table
 *    CREATE TABLE IF NOT EXISTS public.post_likes (
 *        post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        created_at timestamp with time zone DEFAULT now(),
 *        PRIMARY KEY (post_id, user_id)
 *    );
 *    COMMENT ON TABLE public.post_likes IS 'Tracks user likes on posts.';
 *
 *    -- 5. Create post_comments table
 *    CREATE TABLE IF NOT EXISTS public.post_comments (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
 *        author_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        comment text NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.post_comments IS 'Stores comments on posts.';
 *
 *    -- 6. Create post_bookmarks table
 *    CREATE TABLE IF NOT EXISTS public.post_bookmarks (
 *        post_id uuid NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        created_at timestamp with time zone DEFAULT now(),
 *        PRIMARY KEY (post_id, user_id)
 *    );
 *    COMMENT ON TABLE public.post_bookmarks IS 'Stores user bookmarks for posts.';
 *
 *    -- 7. Enable RLS on new tables
 *    ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.post_likes ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.post_comments ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.post_bookmarks ENABLE ROW LEVEL SECURITY;
 *
 *    -- 8. RLS Policies for posts table
 *    DROP POLICY IF EXISTS "Public can view published posts" ON public.posts;
 *    CREATE POLICY "Public can view published posts" ON public.posts FOR SELECT USING (status = 'published');
 *
 *    -- FIX: Add policy for admins and bloggers to view all posts (including drafts)
 *    DROP POLICY IF EXISTS "Admins and bloggers can view all posts" ON public.posts;
 *    CREATE POLICY "Admins and bloggers can view all posts" ON public.posts FOR SELECT USING (public.get_my_role() IN ('admin', 'blog'));
 *    
 *    DROP POLICY IF EXISTS "Bloggers and admins can insert posts" ON public.posts;
 *    CREATE POLICY "Bloggers and admins can insert posts" ON public.posts FOR INSERT WITH CHECK (public.get_my_role() IN ('admin', 'blog'));
 *
 *    DROP POLICY IF EXISTS "Authors, bloggers, and admins can update posts" ON public.posts;
 *    CREATE POLICY "Authors, bloggers, and admins can update posts" ON public.posts FOR UPDATE USING (auth.uid() = author_id OR public.get_my_role() IN ('admin', 'blog'));
 *
 *    DROP POLICY IF EXISTS "Admins can delete any post, authors can delete their own" ON public.posts;
 *    CREATE POLICY "Admins can delete any post, authors can delete their own" ON public.posts FOR DELETE USING (public.get_my_role() = 'admin' OR auth.uid() = author_id);
 *
 *    -- 9. RLS Policies for interaction tables (likes, comments, bookmarks)
 *    DROP POLICY IF EXISTS "Authenticated users can view all" ON public.post_likes;
 *    CREATE POLICY "Authenticated users can view all" ON public.post_likes FOR SELECT USING (auth.role() = 'authenticated');
 *    
 *    DROP POLICY IF EXISTS "Users can manage their own likes" ON public.post_likes;
 *    CREATE POLICY "Users can manage their own likes" ON public.post_likes FOR ALL USING (auth.uid() = user_id);
 *    
 *    DROP POLICY IF EXISTS "Authenticated users can view all" ON public.post_comments;
 *    CREATE POLICY "Authenticated users can view all" ON public.post_comments FOR SELECT USING (auth.role() = 'authenticated');
 *
 *    DROP POLICY IF EXISTS "Users can manage their own comments" ON public.post_comments;
 *    CREATE POLICY "Users can manage their own comments" ON public.post_comments FOR ALL USING (auth.uid() = author_id);
 *    
 *    DROP POLICY IF EXISTS "Authenticated users can view all" ON public.post_bookmarks;
 *    CREATE POLICY "Authenticated users can view all" ON public.post_bookmarks FOR SELECT USING (auth.role() = 'authenticated');
 *
 *    DROP POLICY IF EXISTS "Users can manage their own bookmarks" ON public.post_bookmarks;
 *    CREATE POLICY "Users can manage their own bookmarks" ON public.post_bookmarks FOR ALL USING (auth.uid() = user_id);
 *
 *    -- 10. Trigger function to update post counts
 *    CREATE OR REPLACE FUNCTION update_post_counts()
 *    RETURNS TRIGGER AS $$
 *    BEGIN
 *      IF (TG_OP = 'INSERT') THEN
 *        IF (TG_TABLE_NAME = 'post_likes') THEN
 *          UPDATE posts SET likes_count = likes_count + 1 WHERE id = NEW.post_id;
 *        ELSIF (TG_TABLE_NAME = 'post_comments') THEN
 *          UPDATE posts SET comments_count = comments_count + 1 WHERE id = NEW.post_id;
 *        END IF;
 *      ELSIF (TG_OP = 'DELETE') THEN
 *        IF (TG_TABLE_NAME = 'post_likes') THEN
 *          UPDATE posts SET likes_count = likes_count - 1 WHERE id = OLD.post_id;
 *        ELSIF (TG_TABLE_NAME = 'post_comments') THEN
 *          UPDATE posts SET comments_count = comments_count - 1 WHERE id = OLD.post_id;
 *        END IF;
 *      END IF;
 *      RETURN NULL;
 *    END;
 *    $$ LANGUAGE plpgsql;
 *
 *    -- 11. Create triggers for post counts
 *    DROP TRIGGER IF EXISTS on_like_insert ON public.post_likes;
 *    CREATE TRIGGER on_like_insert AFTER INSERT ON public.post_likes FOR EACH ROW EXECUTE FUNCTION update_post_counts();
 *    DROP TRIGGER IF EXISTS on_like_delete ON public.post_likes;
 *    CREATE TRIGGER on_like_delete AFTER DELETE ON public.post_likes FOR EACH ROW EXECUTE FUNCTION update_post_counts();
 *
 *    DROP TRIGGER IF EXISTS on_comment_insert ON public.post_comments;
 *    CREATE TRIGGER on_comment_insert AFTER INSERT ON public.post_comments FOR EACH ROW EXECUTE FUNCTION update_post_counts();
 *    DROP TRIGGER IF EXISTS on_comment_delete ON public.post_comments;
 *    CREATE TRIGGER on_comment_delete AFTER DELETE ON public.post_comments FOR EACH ROW EXECUTE FUNCTION update_post_counts();
 *
 *    -- ================================================================================================
 *    -- === GALLERY SYSTEM SETUP (NEW)                                                             ===
 *    -- ================================================================================================
 *    -- 1. Create Storage Bucket:
 *    -- Go to your Supabase project -> Storage -> Create bucket
 *    -- Bucket name: gallery_images
 *    -- Check "Public bucket"
 *
 *    -- 2. SQL Policies for 'gallery_images' bucket (run these in the SQL Editor)
 *    -- [FIX] This policy is now more robust. It allows authorized users to upload to a path starting with `public/{their_user_id}/`.
 *    DROP POLICY IF EXISTS "Gallery image insert policy" ON storage.objects;
 *    CREATE POLICY "Gallery image insert policy" ON storage.objects FOR INSERT TO authenticated WITH CHECK (
 *        bucket_id = 'gallery_images'
 *        AND (select get_my_role()) IN ('admin', 'media')
 *        AND name LIKE 'public/' || auth.uid()::text || '/%'
 *    );
 *    
 *    DROP POLICY IF EXISTS "Gallery image update policy" ON storage.objects;
 *    CREATE POLICY "Gallery image update policy" ON storage.objects FOR UPDATE TO authenticated USING (
 *        bucket_id = 'gallery_images' AND (select get_my_role()) IN ('admin', 'media')
 *    );
 *    
 *    DROP POLICY IF EXISTS "Gallery image delete policy" ON storage.objects;
 *    CREATE POLICY "Gallery image delete policy" ON storage.objects FOR DELETE TO authenticated USING (
 *        bucket_id = 'gallery_images' AND (select get_my_role()) IN ('admin', 'media')
 *    );
 *
 *    -- 3. Create gallery_posts table
 *    CREATE TABLE IF NOT EXISTS public.gallery_posts (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        author_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        title text NOT NULL,
 *        category text NOT NULL,
 *        more_images_url text,
 *        image_urls text[] NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.gallery_posts IS 'Stores posts for the media gallery.';
 *
 *    -- 4. Enable RLS
 *    ALTER TABLE public.gallery_posts ENABLE ROW LEVEL SECURITY;
 *
 *    -- 5. RLS Policies
 *    DROP POLICY IF EXISTS "Public can view gallery posts" ON public.gallery_posts;
 *    CREATE POLICY "Public can view gallery posts" ON public.gallery_posts FOR SELECT USING (true);
 *
 *    DROP POLICY IF EXISTS "Media managers and admins can manage gallery posts" ON public.gallery_posts;
 *    CREATE POLICY "Media managers and admins can manage gallery posts" ON public.gallery_posts
 *    FOR ALL USING (public.get_my_role() IN ('admin', 'media'))
 *    WITH CHECK (public.get_my_role() IN ('admin', 'media'));
 *
 *
 *    -- ================================================================================================
 *    -- === RESOURCE LIBRARY SETUP (NEW)                                                          ===
 *    -- ================================================================================================
 *    -- Create resources table
 *    CREATE TABLE IF NOT EXISTS public.resources (
 *        id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
 *        title text NOT NULL,
 *        description text,
 *        category text NOT NULL,
 *        url text NOT NULL,
 *        thumbnail_url text,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.resources IS 'Stores materials like sermon notes, study guides, and videos.';
 *
 *    CREATE TABLE IF NOT EXISTS public.resource_categories (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        name text NOT NULL UNIQUE,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    ALTER TABLE public.resource_categories ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Authenticated users can view resource categories" ON public.resource_categories FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Admins can manage resource categories" ON public.resource_categories FOR ALL USING (public.get_my_role() = 'admin');
 *
 *    -- Enable RLS
 *    ALTER TABLE public.resources ENABLE ROW LEVEL SECURITY;
 *
 *    -- Policies
 *    DROP POLICY IF EXISTS "Authenticated users can view resources" ON public.resources;
 *    CREATE POLICY "Authenticated users can view resources" ON public.resources
 *    FOR SELECT
 *    TO authenticated
 *    USING (true);
 *
 *    DROP POLICY IF EXISTS "Admins can manage resources" ON public.resources;
 *    CREATE POLICY "Admins can manage resources" ON public.resources
 *    FOR ALL
 *    USING (public.get_my_role() = 'admin')
 *    WITH CHECK (public.get_my_role() = 'admin');
 *
 *    -- ================================================================================================
 *    -- === NOTIFICATION SYSTEM SETUP (WITH FIX)                                                     ===
 *    -- ================================================================================================
 *    CREATE TABLE IF NOT EXISTS public.notifications (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        type text NOT NULL,
 *        message text NOT NULL,
 *        metadata jsonb,
 *        link text,
 *        is_read boolean DEFAULT false NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.notifications IS 'Stores notifications for users.';
 *
 *    -- Enable RLS
 *    ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
 *
 *    -- RLS Policies
 *    CREATE POLICY "Users can view their own notifications" ON public.notifications FOR SELECT USING (auth.uid() = user_id);
 *    CREATE POLICY "Authenticated users can create notifications" ON public.notifications FOR INSERT WITH CHECK (auth.role() = 'authenticated');
 *    CREATE POLICY "Users can update their own notifications" ON public.notifications FOR UPDATE USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
 *    CREATE POLICY "Users can delete their own notifications" ON public.notifications FOR DELETE USING (auth.uid() = user_id);
 *
 *    -- ================================================================================================
 *    -- === PUSH NOTIFICATION SETUP (NEW)                                                          ===
 *    -- ================================================================================================
 *    -- Create push_subscriptions table
 *    CREATE TABLE IF NOT EXISTS public.push_subscriptions (
 *        id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
 *        user_id uuid NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
 *        subscription_object jsonb NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.push_subscriptions IS 'Stores user push notification subscriptions.';
 *
 *    -- Enable RLS
 *    ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;
 *
 *    -- Policies
 *    DROP POLICY IF EXISTS "Users can manage their own subscriptions" ON public.push_subscriptions;
 *    CREATE POLICY "Users can manage their own subscriptions" ON public.push_subscriptions
 *    FOR ALL
 *    USING (auth.uid() = user_id)
 *    WITH CHECK (auth.uid() = user_id);
 *
 *    -- ================================================================================================
 *    -- === GAMIFICATION: BIBLE QUIZZES (NEW)                                                        ===
 *    -- ================================================================================================
 *    
 *    -- Add a flag to challenges to indicate if they have a quiz
 *    ALTER TABLE public.weekly_challenges ADD COLUMN IF NOT EXISTS has_quiz boolean DEFAULT false NOT NULL;
 *    
 *    -- 1. Create quizzes table
 *    CREATE TABLE IF NOT EXISTS public.quizzes (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        challenge_id uuid NOT NULL UNIQUE REFERENCES public.weekly_challenges(id) ON DELETE CASCADE,
 *        title text NOT NULL,
 *        coin_reward integer DEFAULT 25 NOT NULL,
 *        pass_threshold integer DEFAULT 2 NOT NULL, -- e.g., 2 out of 3 correct
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    ALTER TABLE public.quizzes ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Authenticated users can view quizzes" ON public.quizzes FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Admins can manage quizzes" ON public.quizzes FOR ALL USING (public.get_my_role() = 'admin');
 *    
 *    -- 2. Create quiz_questions table
 *    CREATE TABLE IF NOT EXISTS public.quiz_questions (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        quiz_id uuid NOT NULL REFERENCES public.quizzes(id) ON DELETE CASCADE,
 *        question_text text NOT NULL,
 *        options jsonb NOT NULL, -- e.g., ["Answer A", "Answer B", "Answer C"]
 *        correct_option_index integer NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    ALTER TABLE public.quiz_questions ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Authenticated users can view questions" ON public.quiz_questions FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Admins can manage questions" ON public.quiz_questions FOR ALL USING (public.get_my_role() = 'admin');
 *    
 *    -- 3. Create quiz_attempts table
 *    CREATE TABLE IF NOT EXISTS public.quiz_attempts (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        quiz_id uuid NOT NULL REFERENCES public.quizzes(id) ON DELETE CASCADE,
 *        score integer NOT NULL,
 *        passed boolean NOT NULL,
 *        created_at timestamp with time zone DEFAULT now(),
 *        UNIQUE(user_id, quiz_id)
 *    );
 *    ALTER TABLE public.quiz_attempts ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Users can manage their own attempts" ON public.quiz_attempts FOR ALL USING (auth.uid() = user_id);
 *    
 *    -- ================================================================================================
 *    -- === GAMIFICATION: VERSE PACKS (NEW)                                                          ===
 *    -- ================================================================================================
 *    -- This table stores which verses a user has collected as a reward.
 *    -- The actual verses can be stored in the app's code.
 *    CREATE TABLE IF NOT EXISTS public.user_verse_rewards (
 *        id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 *        user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        verse_id integer NOT NULL, -- Corresponds to an ID in the app's verse list
 *        unlocked_at timestamp with time zone DEFAULT now(),
 *        UNIQUE (user_id, verse_id)
 *    );
 *    ALTER TABLE public.user_verse_rewards ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Users can manage their own verse rewards" ON public.user_verse_rewards
 *    FOR ALL USING (auth.uid() = user_id)
 *    WITH CHECK (auth.uid() = user_id);
 *
 *    -- ================================================================================================
 *    -- === PRAYER WALL SETUP (NEW)                                                                  ===
 *    -- ================================================================================================
 *    CREATE TABLE IF NOT EXISTS public.prayer_requests (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        request text NOT NULL,
 *        author_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        author_name text NOT NULL,
 *        author_avatar text,
 *        prayers integer DEFAULT 0 NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.prayer_requests IS 'Stores user-submitted prayer requests for the prayer wall.';
 *    ALTER TABLE public.prayer_requests ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Authenticated users can view all prayer requests" ON public.prayer_requests FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Users can insert their own prayer requests" ON public.prayer_requests FOR INSERT WITH CHECK (auth.uid() = author_id);
 *    CREATE POLICY "Users can delete their own requests, admins can delete any" ON public.prayer_requests FOR DELETE USING (auth.uid() = author_id OR public.get_my_role() = 'admin');
 *
 *    -- RPC function to safely increment prayer count
 *    CREATE OR REPLACE FUNCTION increment_prayer_count(request_id_in uuid)
 *    RETURNS void LANGUAGE plpgsql AS $$
 *    BEGIN
 *      UPDATE public.prayer_requests SET prayers = prayers + 1 WHERE id = request_id_in;
 *    END;
 *    $$;
 *
 *    -- ================================================================================================
 *    -- === SCRIPTURE OF THE DAY SETUP (NEW)                                                         ===
 *    -- ================================================================================================
 *    CREATE TABLE IF NOT EXISTS public.scripture_of_the_day (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        verse_reference text NOT NULL,
 *        verse_text text NOT NULL,
 *        date_for date NOT NULL UNIQUE,
 *        set_by uuid REFERENCES public.profiles(id),
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.scripture_of_the_day IS 'Stores the scripture verse for a specific day.';
 *    ALTER TABLE public.scripture_of_the_day ENABLE ROW LEVEL SECURITY;
 *    CREATE POLICY "Authenticated users can view scriptures" ON public.scripture_of_the_day FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Admins can manage scriptures" ON public.scripture_of_the_day FOR ALL USING (public.get_my_role() = 'admin');
 *
 *    -- ================================================================================================
 *    -- === APP-SPECIFIC FEATURES (Existing setup)                                                   ===
 *    -- ================================================================================================
 *    
 *    -- Create messages table
 *    CREATE TABLE IF NOT EXISTS public.messages (
 *        id uuid DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
 *        sender_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 *        recipient_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
 *        text text,
 *        created_at timestamp with time zone DEFAULT now(),
 *        is_read boolean DEFAULT false
 *    );
 *    COMMENT ON TABLE public.messages IS 'Stores private messages between users.';
 * 
 *    -- Add media support to messages table (run this block once)
 *    ALTER TABLE public.messages ADD COLUMN IF NOT EXISTS message_type text DEFAULT 'text'::text NOT NULL;
 *    ALTER TABLE public.messages ADD COLUMN IF NOT EXISTS media_url text;
 *    ALTER TABLE public.messages ALTER COLUMN text DROP NOT NULL;
 *    ALTER TABLE public.messages ADD CONSTRAINT text_or_media_check CHECK (((text IS NOT NULL AND text <> '') OR (media_url IS NOT NULL)));
 *
 *    -- Enable Row Level Security for the messages table
 *    ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
 * 
 *    -- Drop any old, less specific policies if they exist
 *    DROP POLICY IF EXISTS "Allow users to manage their own messages" ON public.messages;
 * 
 *    -- Create policies for the messages table
 *    CREATE POLICY "Allow users to read their own messages"
 *    ON public.messages FOR SELECT
 *    USING (auth.uid() = sender_id OR auth.uid() = recipient_id);
 * 
 *    CREATE POLICY "Allow users to send messages"
 *    ON public.messages FOR INSERT
 *    WITH CHECK (auth.uid() = sender_id);
 * 
 *    CREATE POLICY "Allow users to mark received messages as read"
 *    ON public.messages FOR UPDATE
 *    USING (auth.uid() = recipient_id)
 *    WITH CHECK (auth.uid() = recipient_id);
 * 
 *    CREATE POLICY "Allow users to delete their own sent messages"
 *    ON public.messages FOR DELETE
 *    USING (auth.uid() = sender_id);
 *
 *    -- Create function to mark messages as read
 *    CREATE OR REPLACE FUNCTION public.mark_messages_as_read(p_sender_id uuid)
 *    RETURNS VOID
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER
 *    AS $$
 *    BEGIN
 *      UPDATE public.messages
 *      SET is_read = true
 *      WHERE recipient_id = auth.uid()
 *        AND sender_id = p_sender_id
 *        AND is_read = false;
 *    END;
 *    $$;
 * 
 *    -- Create function to get chat history
 *    create or replace function get_chat_history()
 *    returns table (
 *        other_user_id uuid,
 *        other_user_name text,
 *        other_user_avatar text,
 *        last_message_text text,
 *        last_message_at timestamptz,
 *        unread_count bigint
 *    )
 *    language sql security definer
 *    as $$
 *    with conversations as (
 *        select
 *            case
 *                when sender_id = auth.uid() then recipient_id
 *                else sender_id
 *            end as other_user_id,
 *            text,
 *            message_type, -- Added message_type
 *            created_at,
 *            case
 *                when recipient_id = auth.uid() and is_read = false then 1
 *                else 0
 *            end as is_unread
 *        from messages
 *        where sender_id = auth.uid() or recipient_id = auth.uid()
 *    ),
 *    ranked_conversations as (
 *        select
 *            other_user_id,
 *            text,
 *            message_type, -- Propagate message_type
 *            created_at,
 *            is_unread,
 *            row_number() over(partition by other_user_id order by created_at desc) as rn
 *        from ranked_conversations
 *    ),
 *    latest_messages as (
 *        select
 *            other_user_id,
 *            -- Use a CASE statement to show a placeholder for non-text messages
 *            case
 *                when message_type = 'audio' and (text is null or text = '') then 'Sent a voice message'
 *                else text
 *            end as last_message_text,
 *            created_at as last_message_at
 *        from ranked_conversations
 *        where rn = 1
 *    ),
 *    unread_counts as (
 *        select
 *            other_user_id,
 *            sum(is_unread) as unread_count
 *        from conversations
 *        group by other_user_id
 *    )
 *    select
 *        u.other_user_id,
 *        p.full_name as other_user_name,
 *        p.avatar_url as other_user_avatar,
 *        l.last_message_text,
 *        l.last_message_at,
 *        coalesce(u.unread_count, 0) as unread_count
 *    from unread_counts u
 *    join latest_messages l on u.other_user_id = l.other_user_id
 *    join profiles p on u.other_user_id = p.id
 *    order by l.last_message_at desc;
 *    $$;
 *
 *    -- ================================================================================================
 *    -- === CHAT MEDIA (VOICE NOTES) SETUP (NEW)                                                     ===
 *    -- ================================================================================================
 *
 *    -- 1. Create Storage Bucket for Chat Media:
 *    --    - Go to your Supabase project -> Storage.
 *    --    - Click "Create bucket".
 *    --    - Enter Bucket name: chat_media
 *    --    - IMPORTANT: Check the "Public bucket" option.
 *    --    - Click "Create bucket".
 *
 *    -- 2. SQL Policies for 'chat_media' bucket (run these in the SQL Editor after creating the bucket)
 *
 *    -- This policy allows any logged-in user to view/download any file in the chat media bucket.
 *    DROP POLICY IF EXISTS "Allow authenticated read access on chat media" ON storage.objects;
 *    CREATE POLICY "Allow authenticated read access on chat media"
 *    ON storage.objects FOR SELECT
 *    TO authenticated
 *    USING ( bucket_id = 'chat_media' );
 *
 *    -- This policy allows a logged-in user to upload files into a folder named with their own user ID.
 *    -- Example path: `a1b2c3d4-e5f6/audio.webm`
 *    DROP POLICY IF EXISTS "Allow authenticated users to upload their own chat media" ON storage.objects;
 *    CREATE POLICY "Allow authenticated users to upload their own chat media"
 *    ON storage.objects FOR INSERT
 *    TO authenticated
 *    WITH CHECK ( bucket_id = 'chat_media' AND (storage.foldername(name))[1] = auth.uid()::text );
 *
 *    -- This policy allows a user to delete media files from their own folder.
 *    DROP POLICY IF EXISTS "Allow users to delete their own chat media" ON storage.objects;
 *    CREATE POLICY "Allow users to delete their own chat media"
 *    ON storage.objects FOR DELETE
 *    TO authenticated
 *    USING (
 *      bucket_id = 'chat_media' AND 
 *      ( (storage.foldername(name))[1] = auth.uid()::text )
 *    );
 *
 *    -- This function aggregates various metrics for the leader analytics dashboard.
 *    -- It should be called from a secure, admin-only context.
 *    -- The `security definer` setting allows it to bypass RLS to count across all users.
 *    create or replace function get_dashboard_analytics()
 *    returns json
 *    language plpgsql
 *    security definer
 *    as $$
 *    declare
 *      total_members_count int;
 *      new_members_count int;
 *      active_users_count int;
 *      avg_completion numeric;
 *      weekly_completion_data json;
 *      engagement_data json;
 *      result json;
 *    begin
 *      -- 1. Total members count
 *      select count(*) into total_members_count from public.profiles;
 *
 *      -- 2. New members this month
 *      select count(*) into new_members_count from public.profiles
 *      where created_at >= date_trunc('month', now());
 *
 *      -- 3. Active users in last 24 hours (based on last sign-in)
 *      select count(*) into active_users_count from auth.users
 *      where last_sign_in_at >= now() - interval '24 hours';
 *
 *      -- 4. Average task completion rate over the last 4 weeks
 *      select
 *        coalesce(
 *          (count(*) filter (where status = 'done')) * 100.0 / nullif(count(*), 0),
 *          0
 *        )
 *      into avg_completion
 *      from public.tasks_assignments
 *      where created_at >= now() - interval '4 weeks';
 *
 *      -- 5. Weekly task completion data for the last 4 weeks
 *      with weeks as (
 *        select generate_series(
 *          date_trunc('week', now()) - interval '3 weeks',
 *          date_trunc('week', now()),
 *          '1 week'::interval
 *        ) as week_start
 *      )
 *      select json_agg(
 *        json_build_object(
 *          'name', 'Week of ' || to_char(w.week_start, 'Mon DD'),
 *          'assigned', (
 *            select count(*) from public.tasks_assignments
 *            where created_at >= w.week_start and created_at < w.week_start + interval '1 week'
 *          ),
 *          'completed', (
 *            select count(*) from public.tasks_assignments
 *            where status = 'done' and created_at >= w.week_start and created_at < w.week_start + interval '1 week'
 *          )
 *        ) order by w.week_start
 *      )
 *      into weekly_completion_data
 *      from weeks w;
 *
 *      -- 6. User engagement breakdown
 *      select json_agg(
 *        json_build_object('name', activity, 'value', count)
 *      )
 *      into engagement_data
 *      from (
 *        select 'Tasks' as activity, count(*) from public.tasks_assignments where status = 'done'
 *        union all
 *        select 'Challenges' as activity, count(*) from public.weekly_participants
 *        union all
 *        select 'Messages' as activity, count(*) from public.messages
 *        union all
 *        select 'Prayers' as activity, count(*) from public.prayer_requests
 *      ) as engagement_counts;
 *
 *      -- 7. Combine all results into a single JSON object
 *      select json_build_object(
 *        'totalMembers', json_build_object('value', total_members_count, 'change', new_members_count),
 *        'activeUsers', json_build_object('value', active_users_count, 'total', total_members_count),
 *        'avgTaskCompletion', avg_completion,
 *        'taskCompletion', weekly_completion_data,
 *        'engagement', engagement_data
 *      ) into result;
 *
 *      return result;
 *    end;
 *    $$;
 *
 *    -- UPDATED: Function to approve a coin transaction and update user coins
 *    -- First, remove the function that expects a UUID
 *    DROP FUNCTION IF EXISTS public.approve_coin_transaction(transaction_id uuid);
 * 
 *    -- Now, create the function to correctly accept a BIGINT (int8)
 *    CREATE OR REPLACE FUNCTION approve_coin_transaction(p_transaction_id bigint)
 *    RETURNS void
 *    LANGUAGE plpgsql
 *    SECURITY DEFINER
 *    AS $$
 *    DECLARE
 *      tx_user_id uuid;
 *      tx_coin_amount int;
 *    BEGIN
 *      -- Get user_id and coin_amount from the transaction using the BIGINT id
 *      SELECT user_id, coin_amount INTO tx_user_id, tx_coin_amount
 *      FROM public.coin_transactions
 *      WHERE id = p_transaction_id AND status = 'pending';
 *
 *      -- Proceed only if a pending transaction was found
 *      IF found THEN
 *        -- Update the transaction status to 'approved'
 *        UPDATE public.coin_transactions
 *        SET status = 'approved'
 *        WHERE id = p_transaction_id;
 *
 *        -- Atomically update the user's coin balance
 *        UPDATE public.profiles
 *        SET coins = coins + tx_coin_amount
 *        WHERE id = tx_user_id;
 *      END IF;
 *    END;
 *    $$;
 *
 *    -- NEW: Function to assign a daily task to all users and create notifications
 *    create or replace function assign_task_to_all_users(task_id_to_assign uuid)
 *    returns void
 *    language plpgsql
 *    security definer
 *    as $$
 *    declare
 *      user_record record;
 *      task_title text;
 *    begin
 *      -- Get the task title for the notification message
 *      select title into task_title from public.tasks where id = task_id_to_assign;
 *
 *      -- Loop through all users with a profile
 *      for user_record in select id from public.profiles loop
 *        -- Insert the task assignment
 *        insert into public.tasks_assignments(task_id, assignee_id, status)
 *        values (task_id_to_assign, user_record.id, 'assigned');
 *
 *        -- Create a notification for the user
 *        insert into public.notifications(user_id, type, message, link)
 *        values (user_record.id, 'task_assigned', 'A new daily task has been assigned: "' || task_title || '"', '/tasks');
 *      end loop;
 *    end;
 *    $$;
 * 
 *    -- ================================================================================================
 *    -- === ACADEMICS SYSTEM SETUP (NEW)                                                           ===
 *    -- ================================================================================================
 *
 *    -- 1. Create faculties table
 *    CREATE TABLE IF NOT EXISTS public.faculties (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        name text NOT NULL UNIQUE,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *
 *    -- 2. Create departments table
 *    CREATE TABLE IF NOT EXISTS public.departments (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        name text NOT NULL UNIQUE,
 *        faculty_id uuid NOT NULL REFERENCES public.faculties(id) ON DELETE CASCADE,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *
 *    -- 3. Create courses table
 *    CREATE TABLE IF NOT EXISTS public.courses (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        name text NOT NULL,
 *        code text NOT NULL,
 *        level integer NOT NULL,
 *        department_id uuid REFERENCES public.departments(id) ON DELETE SET NULL, -- Can be null for general courses
 *        faculty_id uuid REFERENCES public.faculties(id) ON DELETE SET NULL, -- Can be null for faculty-wide courses
 *        is_general boolean DEFAULT false NOT NULL,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *
 *    -- 4. Create course_materials table
 *    CREATE TABLE IF NOT EXISTS public.course_materials (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        course_id uuid NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
 *        title text NOT NULL,
 *        type text NOT NULL CHECK (type IN ('pdf_link', 'drive_folder', 'video_link', 'text')),
 *        url text NOT NULL,
 *        description text,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *
 *    -- 5. Create course_borrowers table
 *    CREATE TABLE IF NOT EXISTS public.course_borrowers (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        course_id uuid NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
 *        department_id uuid NOT NULL REFERENCES public.departments(id) ON DELETE CASCADE,
 *        UNIQUE(course_id, department_id)
 *    );
 *
 *    -- 6. Enable RLS
 *    ALTER TABLE public.faculties ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.departments ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.courses ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.course_materials ENABLE ROW LEVEL SECURITY;
 *    ALTER TABLE public.course_borrowers ENABLE ROW LEVEL SECURITY;
 *
 *    -- 7. RLS Policies
 *    -- Authenticated users can view all academic resources
 *    CREATE POLICY "Authenticated users can view academic data" ON public.faculties FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Authenticated users can view academic data" ON public.departments FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Authenticated users can view academic data" ON public.courses FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Authenticated users can view academic data" ON public.course_materials FOR SELECT TO authenticated USING (true);
 *    CREATE POLICY "Authenticated users can view academic data" ON public.course_borrowers FOR SELECT TO authenticated USING (true);
 *
 *    -- Admins and Academics managers can manage all academic resources
 *    CREATE POLICY "Admins and academics managers can manage academic data" ON public.faculties FOR ALL USING (public.get_my_role() IN ('admin', 'academics'));
 *    CREATE POLICY "Admins and academics managers can manage academic data" ON public.departments FOR ALL USING (public.get_my_role() IN ('admin', 'academics'));
 *    CREATE POLICY "Admins and academics managers can manage academic data" ON public.courses FOR ALL USING (public.get_my_role() IN ('admin', 'academics'));
 *    CREATE POLICY "Admins and academics managers can manage academic data" ON public.course_materials FOR ALL USING (public.get_my_role() IN ('admin', 'academics'));
 *    CREATE POLICY "Admins and academics managers can manage academic data" ON public.course_borrowers FOR ALL USING (public.get_my_role() IN ('admin', 'academics'));
 *
 *    -- ================================================================================================
 *    -- === COMMUNITY MATERIALS (USER UPLOADS) SETUP                                                 ===
 *    -- ================================================================================================
 *
 *    -- ========= STEP 1: Create the new user_course_materials table =========
 *    -- This table will store materials uploaded by any authenticated user.
 *    CREATE TABLE IF NOT EXISTS public.user_course_materials (
 *        id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
 *        uploader_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
 *        course_id uuid NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
 *        title text NOT NULL,
 *        file_url text NOT NULL,
 *        file_path text NOT NULL, -- Storing path for easier storage management
 *        description text,
 *        created_at timestamp with time zone DEFAULT now()
 *    );
 *    COMMENT ON TABLE public.user_course_materials IS 'Stores course materials uploaded by users.';
 *
 *
 *    -- ========= STEP 2: Enable RLS and add policies for the new table =========
 *    ALTER TABLE public.user_course_materials ENABLE ROW LEVEL SECURITY;
 *
 *    -- Clear any old policies to prevent conflicts
 *    DROP POLICY IF EXISTS "Authenticated users can view all user materials" ON public.user_course_materials;
 *    DROP POLICY IF EXISTS "Users can manage their own uploaded materials" ON public.user_course_materials;
 *    DROP POLICY IF EXISTS "Users can upload their own materials" ON public.user_course_materials;
 *
 *
 *    -- Allow all authenticated users to view all community-uploaded materials.
 *    CREATE POLICY "Authenticated users can view all user materials" ON public.user_course_materials
 *    FOR SELECT TO authenticated USING (true);
 *
 *    -- Allow users to upload materials, ensuring they set themselves as the uploader.
 *    CREATE POLICY "Users can upload their own materials" ON public.user_course_materials
 *    FOR INSERT TO authenticated WITH CHECK (auth.uid() = uploader_id);
 *
 *    -- Allow users to update or delete only the materials they uploaded. Admins/academics can also manage.
 *    -- Policy to allow users to UPDATE their own uploaded materials
 *    CREATE POLICY "Users can update their own uploaded materials" ON public.user_course_materials
 *    FOR UPDATE TO authenticated
 *    USING (
 *      (auth.uid() = uploader_id) OR (get_my_role() IN ('admin', 'academics'))
 *    );
 *
 *    -- Policy to allow users to DELETE their own uploaded materials
 *    CREATE POLICY "Users can delete their own uploaded materials" ON public.user_course_materials
 *    FOR DELETE TO authenticated
 *    USING (
 *      (auth.uid() = uploader_id) OR (get_my_role() IN ('admin', 'academics'))
 *    );
 *
 *
 *    -- ========= STEP 3: Revert changes to the admin 'course_materials' table =========
 *    -- This removes the 'file_upload' option from the admin-managed materials table.
 *    ALTER TABLE public.course_materials DROP CONSTRAINT IF EXISTS course_materials_type_check;
 *    ALTER TABLE public.course_materials ADD CONSTRAINT course_materials_type_check 
 *    CHECK (type IN ('pdf_link', 'drive_folder', 'video_link', 'text'));
 *
 *
 *    -- ========= STEP 4: Update Storage Bucket Policies for 'course_materials' =========
 *    -- This allows any user to upload files into a folder named with their own user ID.
 *    -- NOTE: Ensure a public bucket named 'course_materials' exists in your Supabase storage.
 *
 *    -- First, clear existing policies on the bucket to avoid conflicts.
 *    DROP POLICY IF EXISTS "Allow authenticated read access" ON storage.objects;
 *    DROP POLICY IF EXISTS "Allow academics and admins to manage course materials" ON storage.objects;
 *    DROP POLICY IF EXISTS "Allow authenticated users to upload their own files" ON storage.objects;
 *    DROP POLICY IF EXISTS "Allow users to delete their own files" ON storage.objects;
 *
 *    -- Allow all authenticated users to view/download any file in the bucket.
 *    CREATE POLICY "Allow authenticated read access"
 *    ON storage.objects FOR SELECT
 *    TO authenticated
 *    USING ( bucket_id = 'course_materials' );
 *
 *    -- Allow any authenticated user to upload files into a folder named with their user ID.
 *    -- The path will look like `public/user-id-goes-here/filename.pdf`
 *    CREATE POLICY "Allow authenticated users to upload their own files"
 *    ON storage.objects FOR INSERT
 *    TO authenticated
 *    WITH CHECK ( bucket_id = 'course_materials' AND (storage.foldername(name))[1] = 'public' AND (storage.foldername(name))[2] = auth.uid()::text );
 *
 *    -- Allow users to delete files from their own folder.
 *    -- Admins/academics managers can also delete any file.
 *    CREATE POLICY "Allow users to delete their own files"
 *    ON storage.objects FOR DELETE
 *    TO authenticated
 *    USING (
 *      bucket_id = 'course_materials' AND 
 *      ( ((storage.foldername(name))[1] = 'public' AND (storage.foldername(name))[2] = auth.uid()::text) OR get_my_role() IN ('admin', 'academics') )
 *    );
 *
 *    ```
 */